!function e(n,t,o){function i(r,c){if(!t[r]){if(!n[r]){var s="function"==typeof require&&require;if(!c&&s)return s(r,!0);if(a)return a(r,!0);var l=new Error("Cannot find module '"+r+"'");throw l.code="MODULE_NOT_FOUND",l}var v=t[r]={exports:{}};n[r][0].call(v.exports,function(e){var t=n[r][1][e];return i(t?t:e)},v,v.exports,e,n,t,o)}return t[r].exports}for(var a="function"==typeof require&&require,r=0;r<o.length;r++)i(o[r]);return i}({1:[function(e,n,t){"use strict";function o(){function e(){n=window.innerWidth,t=window.innerHeight,a&&(a.setSize(n,t),a.setViewport(0,0,n,t),c.aspect=n/t,c.updateProjectionMatrix())}var n,t;n=window.innerWidth,t=window.innerHeight;var o=Math.min(1.5,window.devicePixelRatio),a=new THREE.WebGLRenderer({canvas:document.getElementById("canvas"),antialias:!0});a.setClearColor(1118481,1),a.setSize(n,t),a.setPixelRatio(o);var r=new THREE.Scene,c=new THREE.PerspectiveCamera(35,n/t,1e-4,1e3);c.position.set(0,1,-3),c.lookAt(new THREE.Vector3);var s=new i(c);return window.addEventListener("resize",e),{renderer:a,scene:r,controls:s,camera:c}}var i=e("three-orbit-controls")(THREE);n.exports=o},{"three-orbit-controls":6}],2:[function(e,n,t){"use strict";function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}(),a=function(){function e(){o(this,e)}return i(e,[{key:"multiLoad",value:function(e,n){function t(){o++,o>=e.length&&n()}for(var o=0,i=0;i<e.length;i++)e[i](t)}},{key:"scriptLoad",value:function(e,n){var t=document.createElement("script");t.type="text/javascript",t.src=e;var o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(t,o),t.onload=n}}]),e}();t.LoadingUtil=a},{}],3:[function(e,n,t){"use strict";function o(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0}),t.SoundCloud=void 0;var i,a,r,c,s,l=function(){function e(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(n,t,o){return t&&e(n.prototype,t),o&&e(n,o),n}}(),v=e("./LoadingUtil"),u=new v.LoadingUtil,m="1a2814361cbcccc8033ad0ab9ec86c06",d={},p=!1,x=!1,f=function(){function e(){o(this,e)}return l(e,[{key:"init",value:function(e,n){function t(){console.log("SoundCloudController::scriptLoadComp");var t=document.createElement("canvas");t.id="SoundCloudController_debug",SC.initialize({client_id:m}),SC.get("/resolve",{url:e},function(e){if(console.log(e,e.errors),!e||!e.errors){c.innerHTML+="<a href='"+e.permalink_url+"' target='_blank' >"+e.title+"</a><canvas id='SoundCloudController_equalizer'></canvas>",c.className="__SC__menu",console.log(e),i=document.createElement("audio"),i.crossOrigin="anonymous",i.src=e.stream_url+"?client_id="+m;var o=new(window.AudioContext||window.webkitAudioContext);r=o.createAnalyser(),r.fftSize=2048;var s=o.createMediaElementSource(i);s.connect(r),r.connect(o.destination),a=new Uint8Array(r.frequencyBinCount),x=!0,n(c,t)}})}c=document.createElement("div"),u.multiLoad([function(e){u.scriptLoad("//connect.soundcloud.com/sdk.js",e)},function(e){u.scriptLoad("//cdnjs.cloudflare.com/ajax/libs/processing.js/1.4.8/processing.min.js",e)}],t)}},{key:"debugShow",value:function(){function e(e,n){var t=e.getBoundingClientRect(),o=e.width/t.width,i=e.height/t.height;return{x:(n.clientX-t.left)*o,y:(n.clientY-t.top)*i}}var n=document.getElementById("SoundCloudController_debug");n.style.zIndex=9999,n.style.position="absolute",n.style.top="0px",n.style.left="0px";var t=n.getContext("2d"),o=new Processing(n),i=1024,c=300;o.setup=function(){o.frameRate(32),o.noLoop(),o.background(0),o.size(i,500)};var s=r.frequencyBinCount,l=(Math.round(c/512),Math.round(i/s)),v=0;o.draw=function(){r.getByteFrequencyData(a),o.background(0),o.stroke(255),o.fill(255);for(var e=0;e<.1*s;e++)v=a[e]+Math.abs(a[e]/y(44100/2048*e)),v-=160,o.rect(e*l*10,500,10*(l-2),v*-1),u&&(t.fillStyle="red",t.font="italic 400 24px Unknown Font, sans-serif",t.fillText(parseInt(.1*u.x),10*parseInt(.1*u.x),u.y-30),t.fillStyle="white")},o.setup(),o.loop();var u;n.onmousemove=function(t){u=e(n,t)}}},{key:"getControllerElement",value:function(){return c}},{key:"play",value:function(){function e(){if(setTimeout(e,66),i.volume<.99?i.volume+=.005:i.volume=1,t.clearRect(0,0,25,12),t.beginPath(),p){t.fillStyle="#ffffff";for(var n=0,o=0;o<5;o++)n=4+.01*a[10*o]+Math.random()*(o+2)*4,t.rect(5*o,16-n,4,n)}else{t.fillStyle="#777777";for(var n=0,o=0;o<5;o++)n=10-o,t.rect(5*o,16-n,4,n)}t.fill()}var n=this;if(i.play(),p=!0,!s){s=document.getElementById("SoundCloudController_equalizer");var t=s.getContext("2d");s.width=25,s.height=12,s.onclick=function(){n.togglePlayPause()},i.loop=!0,i.volume=0,e()}}},{key:"togglePlayPause",value:function(){p?this.pause():this.play()}},{key:"pause",value:function(){p=!1,i.pause()}},{key:"stop",value:function(){i.pause(),i.currentTime=0}},{key:"update",value:function(){if(x){r.getByteFrequencyData(a);var e,n=r.frequencyBinCount;for(var t in d)d[t].gain=0;for(var o=0;o<.1*n;o++){e=a[o]+Math.abs(a[o]/y(44100/2048*o));for(var t in d)o==d[t].freq-1&&(d[t].gain+=e/3),o==d[t].freq+0&&(d[t].gain+=e/3),o==d[t].freq+1&&(d[t].gain+=e/3,d[t].gain<=130&&(d[t].gain=0))}}}},{key:"getBytes",value:function(){return a?a:[]}},{key:"getIsPlay",value:function(){return p}},{key:"setPoint",value:function(e,n){d[e]={freq:n,gain:0}}},{key:"removePoint",value:function(e){delete d[e]}},{key:"getGain",value:function(e){return d.hasOwnProperty(e)?d[e].gain:0}}]),e}(),y=function(e){var n=e*e,t=n*n,o=10*Math.log10(1.562339*t/((n+11589.09305)*(n+544440.6705)));return o+=10*Math.log10(2.242881*Math.pow(10,16)*t/(Math.pow(n+424.3186774,2)*Math.pow(n+148699001.4,2)))};t.SoundCloud=f},{"./LoadingUtil":2}],4:[function(e,n,t){"use strict";function o(){x.position.z=1.5,x.lookAt(ne),i(),a()}function i(){j=new GPUComputationRenderer(W,W,y);var e=j.createTexture(),n=j.createTexture(),t=j.createTexture();r(e,n,t),F=j.addVariable("textureVelocity",D,n),I=j.addVariable("texturePosition",M,e),V=j.addVariable("textureAcceleration",L,t),j.setVariableDependencies(F,[I,F,V]),j.setVariableDependencies(I,[I,F,V]),j.setVariableDependencies(V,[I,F,V]),N=I.material.uniforms,U=F.material.uniforms,B=V.material.uniforms,I.material.uniforms.time={value:0},F.material.uniforms.time={value:0},V.material.uniforms.time={value:0},I.material.uniforms.texture1={type:"t",value:null},F.material.uniforms.texture1={type:"t",value:null},F.material.uniforms.amount={type:"f",value:null},V.material.uniforms.texture1={type:"t",value:null},V.material.uniforms.texture2={type:"t",value:null},j.init()}function a(){function e(){new dat.GUI}R=new THREE.PointLight(16777215,1,100,100),R.position.set(0,.8,-2),f.add(R);var n=new THREE.DirectionalLight(16777215);console.log(n.position),f.add(n);for(var t,o,i=new THREE.BufferGeometry,a=new Float32Array(3*Z),r=.002,l=.002,u=.002,m=[0,-1,-1,0,1,0,.866025,-1,.5,.866025,-1,.5,0,1,0,-.866025,-1,.5,-.866025,-1,.5,0,1,0,0,-1,-1,0,-1,-1,.866025,-1,.5,-.866025,-1,.5],d=0;d<3*Z;d+=36){t=.1+2*Math.random(),o=.1+2*Math.random();for(var p=0;p<108;p+=3)a[d+p+0]=m[p+0]*r*t*t*t,a[d+p+1]=m[p+1]*l*o*t*o,a[d+p+2]=m[p+2]*u*o*o*o}for(var y=new Float32Array(2*Z),h=0,g=0;g<W;g++)for(var d=0;d<W;d++)y[h++]=d/(W-1),y[h++]=g/(W-1);for(var w=new Float32Array(Z),d=0;d<Z;d++)w[d]=d;i.addAttribute("position",new THREE.BufferAttribute(a,3)),i.addAttribute("uv",new THREE.BufferAttribute(y,2)),i.addAttribute("index2",new THREE.BufferAttribute(w,1)),G=THREE.UniformsUtils.merge([THREE.UniformsLib.lights,{},{texture1:{type:"t",value:null},texturePosition:{value:null},textureVelocity:{value:null},textureAcceleration:{value:null},amount:{type:"f",value:0},cameraConstant:{value:c(x)},invMatrix:{value:new THREE.Matrix4}}]);var M=new THREE.ShaderMaterial({uniforms:G,vertexShader:P,fragmentShader:E,side:THREE.DoubleSide,vertexColors:THREE.VertexColors,transparent:!0,lights:!0});M.extensions.derivatives=!0,M.extensions.drawBuffers=!0;var D=new THREE.Mesh(i,M);D.matrixAutoUpdate=!1,D.updateMatrix(),f.add(D);var L=new THREE.Matrix4;L.copy(D.matrixWorld),L.multiply(x.matrixWorldInverse);var d=(new THREE.Matrix4).getInverse(L);M.uniforms.invMatrix.value=d;for(var t,o,S=9036,j=new THREE.BufferGeometry,F=new Float32Array(3*S),r=.04,l=.04,u=.04,m=[0,-1,-1,0,1,0,.866025,-1,.5,.866025,-1,.5,0,1,0,-.866025,-1,.5,-.866025,-1,.5,0,1,0,0,-1,-1,0,-1,-1,.866025,-1,.5,-.866025,-1,.5],d=0;d<3*S;d+=36){t=1;for(var p=0;p<108;p+=3)F[d+p+0]=m[p+0]*r*t,F[d+p+1]=m[p+1]*r*t,F[d+p+2]=m[p+2]*r*t}for(var I=new Float32Array(2*S),h=0,g=0;g<W;g++)for(var d=0;d<W;d++)I[h++]=d/(W-1),I[h++]=g/(W-1);for(var V=new Float32Array(3*S),d=0;d<3*S;d+=3)V[d+0]=2*Math.random()-1,V[d+1]=2*Math.random()-1,V[d+2]=2*Math.random()-1;for(var N=new Float32Array(S),d=0;d<S;d++)N[d]=d;j.addAttribute("position",new THREE.BufferAttribute(F,3)),j.addAttribute("uv",new THREE.BufferAttribute(I,2)),j.addAttribute("bodyRotation",new THREE.BufferAttribute(V,3)),j.addAttribute("bodyIndex",new THREE.BufferAttribute(N,1));var U="./imgs/SwedishRoyalCastle_/",B=[U+"pz.jpg",U+"nz.jpg",U+"pz.jpg",U+"nz.jpg",U+"pz.jpg",U+"nz.jpg"],q=THREE.ImageUtils.loadTextureCube(B);Y=Object.assign(THREE.UniformsLib.lights,{texture1:{type:"t",value:null},soundCloudTexture:{type:"t",value:null},soundCloudHigh:{type:"f",value:0},soundCloudLow:{type:"f",value:0},envMap:{type:"t",value:q},texturePosition:{value:null},textureVelocity:{value:null},textureAcceleration:{value:null},cameraConstant:{value:c(x)},invMatrix:{value:new THREE.Matrix4}});var X=new THREE.ShaderMaterial({uniforms:Y,vertexShader:T,fragmentShader:C,side:THREE.DoubleSide,vertexColors:THREE.VertexColors,transparent:!0,lights:!0});X.extensions.derivatives=!0,X.extensions.drawBuffers=!0;var K=new THREE.Mesh(j,X);K.matrixAutoUpdate=!1,K.updateMatrix(),f.add(K);var L=new THREE.Matrix4;L.copy(K.matrixWorld),L.multiply(x.matrixWorldInverse);var d=(new THREE.Matrix4).getInverse(L);X.uniforms.invMatrix.value=d;var J=function(e){if(e.lengthComputable){var n=e.loaded/e.total*100;console.log(Math.round(n,2)+"% downloaded")}},ee=function(e){},ne="models/mmd/model.pmx";_=new THREE.MMDHelper;var te=new THREE.MMDLoader;te.loadModel(ne,function(n){console.log(n);for(var t=new Float32Array(n.geometry.attributes.position.count),o=0;o<n.geometry.attributes.position.count;o++)t[o]=o;n.geometry.addAttribute("index2",new THREE.BufferAttribute(t,1));for(var i=[],o=0,a=n.material.materials.length;o<a;o++){var r=new THREE.ShaderMaterial({vertexShader:z,fragmentShader:b,skinning:!0,wireframe:!0});i.push(r)}var c=new THREE.MultiMaterial(i);n.material=c,window.mmdMesh=n,H=n,H.scale.set(.4,.4,.4),H.position.x=-1.4,Q.add(H),_.add(H);var l=[{name:"dance1",file:"models/mmd/vmds/dance.vmd"},{name:"dance2",file:"models/mmd/vmds/dance2.vmd"},{name:"dance3",file:"models/mmd/vmds/northern_soul_spin_combo.vmd"},{name:"dance4",file:"models/mmd/vmds/northern_soul_floor_combo.vmd"},{name:"dance5",file:"models/mmd/vmds/mma_kick.vmd"},{name:"dance6",file:"models/mmd/vmds/breakdance_freezes.vmd"},{name:"dance7",file:"models/mmd/vmds/breakdance_footwork_1.vmd"}],u=0,m=function t(){var o=l[u].file;te.loadVmd(o,function(o){if(te.createAnimation(n,o,l[u].name),u++,u<l.length)t();else{_.setAnimation(H),H.mixer.stopAllAction(),A={};for(var i=0;i<H.geometry.animations.length;++i){var a=H.geometry.animations[i],r=H.mixer.clipAction(a);A[H.geometry.animations[i].name]=r,r.repetitions="Infinity"}window.motionObj=A,k.push(A.dance1),A.dance1.play(),O.push(A.dance2),O.push(A.dance3),O.push(A.dance4),O.push(A.dance5),O.push(A.dance6),O.push(A.dance7),window.mmdMesh.mixer.timeScale=1.11851851851,$(document).keypress(function(e){switch(e.which){case 97:s("dance1");break;case 115:s("dance2");break;case 100:s("dance3");break;case 102:s("dance4");break;case 103:s("dance5");break;case 104:s("dance6");break;case 106:s("dance7")}}),e(),v()}},J,ee)};m()},J,ee)}function r(e,n,t){var o=e.image.data,i=n.image.data,a=t.image.data;console.log("pos",o.length),console.log("vel",i.length);for(var r=0,c=0,s=o.length;c<s;c+=144){r++;for(var l=0,v=0,u=0,m=r,d=0;d<144;d+=4)o[c+d+0]=l,o[c+d+1]=v,o[c+d+2]=u,o[c+d+3]=m;var p=0,x=0,f=0;m=Math.random();for(var d=0;d<144;d+=4)i[c+d+0]=p,i[c+d+1]=x,i[c+d+2]=f,i[c+d+3]=m;for(var y=.01*Math.random()-.005,h=-1e-4,g=.01*Math.random()-.005,d=0;d<144;d+=4)a[c+d+0]=y,a[c+d+1]=h,a[c+d+2]=g,a[c+d+3]=0}}function c(e){return window.innerHeight/(Math.tan(.5*THREE.Math.DEG2RAD*e.fov)/e.zoom)}function s(e){S=!1,window.stopList=window.stopList.concat(window.playList.splice(0,window.playList.length)),window.stopList.forEach(function(n,t){n._clip.name==e&&(window.playList=window.stopList.splice(t,1),window.playList[0].time=0,window.playList[0].play())})}function l(){window.stopList=window.stopList.concat(window.playList.splice(0,window.playList.length)),window.stopList.forEach(function(e,n){"dance1"==e._clip.name&&(window.playList=window.stopList.splice(n,1),window.playList[0].play())})}function v(){requestAnimationFrame(v),w.update(),oe+=.003,oe>6.28&&(oe-=6.28),ie+=.01,ie>6.28&&(ie-=6.28),x.position.x=2*Math.cos(oe),x.position.y=1+.5*Math.cos(ie),x.position.z=1+2*Math.sin(oe)+.5*Math.sin(ie),R.position.x=x.position.x,R.position.y=x.position.y,R.position.z=x.position.z,window.mmdMesh&&(te.x+=(0*mmdMesh.skeleton.bones[0].position.x-te.x)/10,te.y+=(0*mmdMesh.skeleton.bones[0].position.y-te.y)/10,te.z+=(.01*mmdMesh.skeleton.bones[0].position.z-te.z)/10),ne.set(te.x,.3+te.y,te.z),x.lookAt(ne),A&&(window.playList.forEach(function(e){e.weight+=(1-e.weight)/10,e.weight>.9999&&(e.weight=1),e._clip.duration-.1<e.time&&0==S&&(S=!0,l())}),window.stopList.forEach(function(e){e.weight+=(0-e.weight)/10,e.weight<1e-4&&(e.weight=0)})),u()}function u(){_.animate(q.getDelta()),y.render(Q,x,J),K&&(K.texture1.value=J.texture),j.compute(),F.material.uniforms.time.value+=1/60,I.material.uniforms.time.value+=1/60,V.material.uniforms.time.value+=1/60,A&&(G.amount.value=1-A.dance1.weight,F.material.uniforms.amount.value=1-A.dance1.weight),F.material.uniforms.texture1.value=J.texture,I.material.uniforms.texture1.value=J.texture,V.material.uniforms.texture1.value=J.texture,V.material.uniforms.texture2.value=ee.texture,G.texture1.value=J.texture,Y.texture1.value=J.texture,g&&(g.image.data=w.getBytes(),g.needsUpdate=!0,Y.soundCloudTexture.value=g,Y.soundCloudHigh.value=1,Y.soundCloudLow.value=.5+1e-8*Math.pow(w.getGain("low"),3)),G.texturePosition.value=j.getCurrentRenderTarget(I).texture,G.textureVelocity.value=j.getCurrentRenderTarget(F).texture,G.textureAcceleration.value=j.getCurrentRenderTarget(V).texture,Y.texturePosition.value=j.getCurrentRenderTarget(I).texture,Y.textureVelocity.value=j.getCurrentRenderTarget(F).texture,Y.textureAcceleration.value=j.getCurrentRenderTarget(V).texture,y.render(f,x),y.render(Q,x,ee)}var m=e("./lib/SoundCloud.js"),d=e("./lib/CreateThree"),p=d(),x=p.camera,f=p.scene,y=p.renderer,h=(p.controls,e("glslify")),g=void 0,w=new m.SoundCloud;w.init("https://soundcloud.com/gradesofficial/king-chris-lake-remix",function(e,n){document.body.appendChild(e),g=new THREE.DataTexture(w.getBytes(),8,8,THREE.RGBFormat),g.needsUpdate=!0,window.soundCloudTexture=g,w.setPoint("low",32),w.setPoint("high",13),w.play(),window.soundCloud=w});var b=h(["#define GLSLIFY 1\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\n//varying vec4 vPosition;\nvarying vec3 vColor;\n\nvoid main() {\n//  gl_FragColor = vec4(1.0,  // R\n//                      0.0,  // G\n//                      1.0,  // B\n//                      1.0); // A\n  gl_FragColor = vec4(vColor,1.0);\n}"]),z=h(["#define GLSLIFY 1\n/**\n * Multiply each vertex by the\n * model-view matrix and the\n * projection matrix (both provided\n * by Three.js) to get a final\n * vertex position\n */\n//   varying vec2 vUv;\n//    uniform mat4 bindMatrix;\n//    uniform mat4 bindMatrixInverse;\n//    uniform mat4 boneMatrices[ MAX_BONES ];\nuniform float offset;\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n\n//varying vec4 vPosition;\nvarying vec3 vColor;\nattribute float index2;\n\nconst float frag = 1.0 / 128.;\nconst float texShift = 0.5 * frag;\n\nvoid main() {\n\n  vec3 transformed = vec3(position + normal * offset);\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n\n\tvec4 mvPosition = modelViewMatrix * skinned;\n\n  vec4 pos1 = modelMatrix * skinned * 0.1;\n  //  vec4 pos1 = vec4(position,1.0);\n  //  vColor = ((normalize(pos1) + 1.0) * 0.5).xyz;\n  vColor = (1.0 + pos1.xyz) * 0.5;\n\n  float pu = fract(index2 * frag) * 2.0 - 1.0;\n  float pv = floor(index2 * frag) * frag * 2.0 - 1.0;\n  gl_Position = vec4(pu + texShift, pv + texShift, 0.0, 1.0);\n  gl_PointSize = 1.0;\n\n//  vPosition = skinned;\n  //gl_Position = projectionMatrix * mvPosition;\n\n }"]),E=(h(["#define GLSLIFY 1\n/**\n * Set the colour to a lovely pink.\n * Note that the color is a 4D Float\n * Vector, R,G,B and A and each part\n * runs from 0.0 to 1.0\n */\n\nuniform sampler2D texture1;\n\nvoid main() {\n\n//  gl_FragColor = texture2D( texture1, gl_PointCoord );\n//  gl_FragColor = vec4(0.3,  // R\n//                      0.1,  // G\n//                      0.1,  // B\n//                      0.3); // A\n//      gl_FragColor = vec4( 63.0/255.0, 81.0/255.0, 100.0/255.0,  1.0 );\n//      gl_FragColor = vec4( 1.0, 1.0, 1.0,  0.03 );\n//    gl_FragColor = vec4( 1.0, 1.0, 1.0,  1.0 );\n    gl_FragColor = vec4( 0.0, 1.0, 0.0,  .2 );\n\n//    gl_FragColor = vColor;\n}"]),h(["#define GLSLIFY 1\n/**\n * Multiply each vertex by the\n * model-view matrix and the\n * projection matrix (both provided\n * by Three.js) to get a final\n * vertex position\n */\n\nuniform sampler2D texture1;\n//varying vec4 vColor;\n\nattribute float index2;\nconst float frag = 1.0 / 128.0;\nconst float texShift = 0.5 * frag;\n\nvoid main() {\n\n    float pu = fract(index2 * frag + texShift);\n    float pv = floor(index2 * frag) * frag + texShift;\n    vec3 tPosition = texture2D(texture1, vec2(pu, pv)).rgb * 2.0 - 1.0;\n\n    gl_Position  = projectionMatrix * viewMatrix * vec4(tPosition, 1.0);\n    gl_PointSize = 1.0;\n\n}"]),h(["precision highp float;\n#define GLSLIFY 1\n\nstruct PointLight {\n  vec3 position;\n  vec3 color;\n  float distance;\n};\n\nuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\nuniform mat4 invMatrix;\n\nvarying vec4 vPosition;\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n\n    vec3 dx = dFdx(vPosition.xyz);\n    vec3 dy = dFdy(vPosition.xyz);\n    vec3 fnormal = normalize(cross(normalize(dx), normalize(dy)));\n\n    vec3 lightPos = pointLights[0].position;\n    vec3 lightDirection = normalize( vPosition.xyz - lightPos );\n\n    vec3 invLight = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n    float diffuse  = clamp(dot(fnormal, invLight), 0.5, 1.0);\n\n    vUv;\n    vColor;\n    vPosition;\n\n//    gl_FragColor = vColor;\n    gl_FragColor = vColor * vec4(vec3(diffuse), 1.0);\n\n}\n"])),P=h(["#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D texturePosition;\nuniform sampler2D textureVelocity;\nuniform sampler2D textureAcceleration;\nuniform float cameraConstant;\nuniform float density;\n\nvarying vec4 vPosition;\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nuniform float radius;\nuniform float amount;\n\n//uniform sampler2D texture1;\n////varying vec4 vColor;\n//\n//attribute float index2;\n//const float frag = 1.0 / 128.0;\n//const float texShift = 0.5 * frag;\n\nvoid main() {\n\n    vec4 velTemp = texture2D( textureVelocity, uv );\n    vec4 accTemp = texture2D( textureAcceleration, uv );\n    vec4 posTemp = texture2D( texturePosition, uv );\n\n//    vColor = vec4( 63.0/255.0, 81.0/255.0, 100.0/255.0,  0.7 );\n//    vColor = vec4( 1.0 - velTemp.xxx * 50.0, 0.8  - zzz * 0.8);\n//    vColor = vec4( 63.0/255.0, 81.0/255.0, 100.0/255.0,  0.7  - zzz * 0.7 );\n//    vColor = vec4( 240./255.0, 240./255.0, 240./255.0, 1.0 );\n//    vColor = vec4( .0, 240./255.0, .0,  0.3  - zzz * 0.3);\n\n    //pos += position;\n\n    // pos is the position of each box\n    vec3 pos = posTemp.xyz;\n\n    // position is box's position. it has 6 faces\n    vec3 newPosition = position * amount;\n\n    newPosition = mat3( modelMatrix ) * newPosition;\n\n    // rotatoin\n    velTemp = posTemp;\n    velTemp.z *= -1.;\n    float xz = length( velTemp.xz );\n    float xyz = 1.;\n    float x = sqrt( 1. - velTemp.y * velTemp.y );\n    float cosry = velTemp.x / xz;\n    float sinry = velTemp.z / xz;\n    float cosrz = x / xyz;\n    float sinrz = velTemp.y / xyz;\n    mat3 maty =  mat3(\n      cosry, 0, -sinry,\n      0    , 1, 0     ,\n      sinry, 0, cosry\n    );\n    mat3 matz =  mat3(\n      cosrz , sinrz, 0,\n      -sinrz, cosrz, 0,\n      0     , 0    , 1\n    );\n\n    newPosition = maty * matz * newPosition;\n\n    newPosition += pos;\n\n//    float pu = fract(index2 * frag + texShift);\n//    float pv = floor(index2 * frag) * frag + texShift;\n//    vec3 tPosition = texture2D(texture1, vec2(pu, pv)).rgb * 2.0 - 1.0;\n\n//    pos = tPosition;\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\n\n    vPosition = gl_Position;\n\n    //vColor = vec4( 1.0, 1.0, 1.0 - accTemp.w * 0.03 , 1.0 );\n    float per = accTemp.w * 0.03;\n    vColor = vColor = vec4( gl_Position.zxy, 1.0 ) * (1.0-per) +\n            //vec4( 247.0/255.0, 240.0/255.0, 92.0/255.0, 1.0 ) * (1.0-per) +\n//                 vec4( 52.0/255.0, 38.0/255.0, 91.0/255.0, 1.0 ) * (per);\n                vec4( 240.0/255.0, 240.0/255.0, 35.0/255.0, 1.0 ) * (per);\n\n}"]),C=h(["precision highp float;\n#define GLSLIFY 1\n\n//struct PointLight {\n//  vec3 position;\n//  vec3 color;\n//  float distance;\n//};\n\n//uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\nuniform mat4 invMatrix;\n\nvarying vec4 vPosition;\n//varying vec4 vColor;\n//varying vec2 vUv;\n\nuniform samplerCube envMap;\n//varying vec3 vReflect;\nvarying float vReflectionFactor;\n\nvarying vec4 vWorldPosition;\nvarying mat3 vModelMatrix;\nvarying vec3 vCameraPosition;\n\nvoid main() {\n\n    //vReflect;\n    vReflectionFactor;\n\n    vec3 dx = dFdx(vPosition.xyz);\n    vec3 dy = dFdy(vPosition.xyz);\n    vec3 fnormal = normalize(cross(normalize(dx), normalize(dy)));\n\n    vec3 worldNormal = normalize( vModelMatrix * fnormal );\n    vec3 I = vWorldPosition.xyz - vCameraPosition;\n\n    vec3 vReflect = reflect( I, worldNormal );\n\n    vec4 envColor = textureCube( envMap, vec3( -vReflect.x, vReflect.yz ) );\n    gl_FragColor = vec4(mix(vec3(1.,1.,0.), envColor.xyz, vec3(clamp( vReflectionFactor, 0.0, 0.95 ))), 1.0);\n\n  /*\n    vec3 dx = dFdx(vPosition.xyz);\n    vec3 dy = dFdy(vPosition.xyz);\n    vec3 fnormal = normalize(cross(normalize(dx), normalize(dy)));\n\n    vec3 lightPos = pointLights[0].position;\n    vec3 lightDirection = normalize( vPosition - lightPos );\n\n    vec3 invLight = normalize(invMatrix * vec4(lightDirection, 0.0)).xyz;\n    float diffuse  = clamp(dot(fnormal, invLight), .5, 1.0);\n\n    vUv;\n    vColor;\n    vPosition;\n\n//    gl_FragColor = vColor;\n    gl_FragColor = vColor * vec4(vec3(diffuse), 1.0);\n*/\n}\n"]),T=h(["#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D texturePosition;\nuniform sampler2D textureVelocity;\nuniform sampler2D textureAcceleration;\nuniform float cameraConstant;\nuniform float density;\n\nuniform float soundCloudLow;\nuniform float soundCloudHigh;\n\nvarying vec4 vPosition;\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nuniform float radius;\n//uniform int audioGain[ 4 ];\n\nuniform sampler2D texture1;\nuniform sampler2D soundCloudTexture;\n//varying vec4 vColor;\n\nattribute float bodyIndex;\nattribute vec3 bodyRotation;\n\nconst float frag = 1.0 / 128.0;\nconst float texShift = 0.5 * frag;\n\n//varying vec3 vReflect;\nvarying float vReflectionFactor;\nvarying vec4 vWorldPosition;\nvarying mat3 vModelMatrix;\nvarying vec3 vCameraPosition;\n\nfloat magSq(vec3 vec) {\n  return (vec.x*vec.x + vec.y*vec.y + vec.z*vec.z);\n}\n\nvec3 limit(vec3 vec, float max) {\n  if (magSq(vec) > max*max) {\n    vec = normalize(vec);\n    vec *= max;\n  }\n  return vec;\n}\n\nfloat rand2(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n\n    vec4 velTemp = texture2D( textureVelocity, uv );\n//    vec4 accTemp = texture2D( textureAcceleration, uv );\n    vec4 tmpPos = texture2D( texturePosition, uv );\n\n//    vColor = vec4( 63.0/255.0, 81.0/255.0, 100.0/255.0,  0.7 );\n//    vColor = vec4( 1.0 - velTemp.xxx * 50.0, 0.8  - zzz * 0.8);\n//    vColor = vec4( 63.0/255.0, 81.0/255.0, 100.0/255.0,  0.7  - zzz * 0.7 );\n//    vColor = vec4( 240./255.0, 240./255.0, 240./255.0, 1.0 );\n//    vColor = vec4( .0, 240./255.0, .0,  0.3  - zzz * 0.3);\n\n    float index = tmpPos.w*50.0;//rand(tmpPos.xy)*12200.;\n    float pu = fract(index * frag + texShift);\n    float pv = floor(index * frag) * frag + texShift;\n    vec3 tmpDan = texture2D( texture1, vec2(pu, pv)).rgb * 2.0 - 1.0;\n\n    vec3 soundCloud = texture2D( soundCloudTexture, vec2(pu, pv)).rgb*2.0;\n    float power = length(limit(0.5+soundCloud,2.0)) * soundCloudLow;\n\n//    tmpDan *= 1.0+soundCloud;\n\n    //pos += position;\n\n    // pos is the position of each box\n//    vec3 pos = posTemp.xyz;\n\n    // position is box's position. it has 6 faces\n    vec3 newPosition = position;\n//\n    newPosition = mat3( modelMatrix ) * newPosition;\n//\n//    // rotatoin\n    float aa = rand2(tmpPos.ww);\n    velTemp = vec4(aa,aa*-power,aa*power*2.0,0.0);\n    velTemp.z *= -1.;\n    float xz = length( velTemp.xz );\n    float xyz = 1.;\n    float x = sqrt( 1. - velTemp.y * velTemp.y );\n    float cosry = velTemp.x / xz * (1.0+aa);\n    float sinry = velTemp.z / xz;\n    float cosrz = x / xyz;\n    float sinrz = velTemp.y / xyz;\n    mat3 maty =  mat3(\n      cosry, 0, -sinry,\n      0    , 1.0, 0  ,\n      sinry, 0, cosry\n    );\n    mat3 matz =  mat3(\n      cosrz , sinrz, 0,\n      -sinrz, cosrz, 0,\n      0     , 0    , 1.0\n    );\n    mat3 scale =  mat3(\n      power , 0, 0,\n      0, power, 0,\n      0     , 0  , power\n    );\n//    mat3 trans =  mat3(\n//          1 , 0, 0,\n//          0,1, 0,\n//          power  , power    , 1\n//        );\n\n    newPosition = scale * maty * matz  * newPosition;\n\n//    newPosition += pos;\n\n    power *= 0.01;\n    tmpDan.x += rand(tmpPos.yx)*power - power*.5;\n    tmpDan.y += rand(tmpPos.xz)*power - power*.5;\n    tmpDan.z += rand(tmpPos.xz)*power - power*.5;\n\n    newPosition += tmpDan;\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\n\n    vPosition = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );;\n\n    //vColor = vec4( 1.0, 1.0, 1.0 - accTemp.w * 0.03 , 1.0 );\n\n//    vColor = vec4( 0.0/255.0, 250.0/255.0, 92.0/255.0, 1.0 );\n    vColor = vec4( 255.0/255.0, 40.0/255.0, 92.0/255.0, 1.0 );\n//    vColor = vec4( 230.0/255.0, 230.0/255.0, 230.0/255.0, 1.0 );\n//    vColor = vec4( newPosition-bodyRotation*0.1, 1.0 );\n\n    vec4 mvPosition = modelViewMatrix * vec4( vPosition.xyz, 1.0 );\n    vec4 worldPosition = modelMatrix * vec4( vPosition.xyz, 1.0 );\n    vWorldPosition = worldPosition;\n    vModelMatrix = mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz );\n    //vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n    //vec3 I = worldPosition.xyz - cameraPosition;\n    vCameraPosition = cameraPosition;\n    //vReflect = reflect( I, worldNormal );\n    vReflectionFactor = 1.0;//fresnelBias + fresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), fresnelPower );\n\n}"]),M=h(["#define GLSLIFY 1\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n#define delta ( 1.0 / 60.0 )\n#define area 2.0\n\n//varying vec4 vColor;\nuniform float time;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nuniform sampler2D texture1;\n\n//attribute float index2;\n\nconst float frag = 1.0 / 128.0;\nconst float texShift = 0.5 * frag;\n\nvoid main() {\n\n  vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n  vec4 tmpPos = texture2D( texturePosition, uv );\n  vec4 tmpVel = texture2D( textureVelocity, uv );\n  vec4 tmpAcc = texture2D( textureAcceleration, uv );\n\n  //vec4 tmpDan = textur  1e2D( textureDance, uv );\n  float idParticle = uv.y * resolution.x + uv.x;\n\n  //float index = uv.x * 128. * uv.y * 128.;\n  //float index = rand(uv) * 5461. ;\n  //float index = rand(uv) * 12200. ;\n\n  // getting skkinned mesh position\n  float index = tmpPos.w;\n  float pu = fract(index * frag + texShift);\n  float pv = floor(index * frag) * frag + texShift;\n  vec3 tmpDan = texture2D( texture1, vec2(pu, pv)).rgb * 2.0 - 1.0;\n\n  vec4 pos = tmpPos;\n  vec3 vel = tmpVel.xyz;\n\n//  float theta = snoise( tmpPos.xyz * (0.9) )*6.28;\n//  vel += vec3( cos(theta), sin(theta), 0.0 )*0.03;\n\n//  vel *= 0.00;\n//  float theta = snoise( tmpPos.xyz * (0.3 + cos(time)*0.1)  )*6.28;\n//  float theta = snoise( tmpPos.xyz * (1.0) )*6.28;\n//  vel += vec3( cos(theta), sin(theta), -1.0 )*0.03;\n\n//  vel.z += -0.0001;\n\n//  (pos.y>0.0)?(pos += vec4(vel.xyz,0.0)):vec4(0.0);\n\n  // Dynamics\n  pos.xyz += vel.xyz;// * delta;\n\n  //stop on a ground\n//  (pos.y<=0.001)?(pos = vec4(pos.x,0,pos.z, pos.w )):vec4(0.0);\n\n  (pos.y<=0.001)?(pos = vec4(pos.x, 0. ,pos.z, pos.w )):vec4(0.0);\n  (tmpVel.w>10.)?(pos = vec4(tmpDan.x,tmpDan.y + rand(tmpDan.xy)*0.03,tmpDan.z, pos.w )):vec4(0.0);\n\n//  pos += vec3(0.0,0.0,-0.1);\n//   pos = tmpDan;\n//  pos.x>area?pos=vec3(pos.x-area*2.0, pos.y         , pos.z         ):vec3(0.0);\n//  pos.y>area?pos=vec3(pos.x         , pos.y-area*2.0, pos.z         ):vec3(0.0);\n//  pos.z>area?pos=vec3(pos.x         , pos.y         , pos.z-area*2.0):vec3(0.0);\n//\n//  pos.x<-area?pos=vec3(pos.x+area*2.0, pos.y         , pos.z         ):vec3(0.0);\n//  pos.y<-area?pos=vec3(pos.x         , pos.y+area*2.0, pos.z         ):vec3(0.0);\n//  pos.z<-area?pos=vec3(pos.x         , pos.y         , pos.z+area*2.0):vec3(0.0);\n\n//  pos.x>area?pos=vec3(pos.x-tmpDan.x , pos.y          , pos.z    ):vec3(0.0);\n//  pos.y>area?pos=vec3(pos.x          , pos.y-tmpDan.y , pos.z    ):vec3(0.0);\n//  pos.z>area?pos=vec3(pos.x          , pos.y          , pos.z-tmpDan.z ):vec3(0.0);\n//\n//  pos.x<-area?pos=vec3(pos.x+tmpDan.x, pos.y          , pos.z    ):vec3(0.0);\n//  pos.y<-area?pos=vec3(pos.x         , pos.y+tmpDan.y , pos.z    ):vec3(0.0);\n//  pos.z<-area?pos=vec3(pos.x         , pos.y          , pos.z+tmpDan.z ):vec3(0.0);\n\n//  pos.x>area?pos=tmpDan:vec3(0.0);\n//  pos.y>area?pos.xyz=tmpDan.xyz:vec3(0.0);\n//  pos.z>area*2.0?pos=tmpDan:vec3(0.0);\n\n//  pos.x<-area?pos=tmpDan:vec3(0.0);\n\n//  pos.z<-area*2.0?pos=tmpDan:vec3(0.0);\n\n//vel.y<0.0001?(vel.y>0.0?pos = vec4(tmpDan.xyz, pos.w ):vec4(0.0)):vec4(0.0);\n\n  // pos.w is the index of the skkinned\n  gl_FragColor = vec4( pos );\n\n}"]),D=h(["#define GLSLIFY 1\n// For PI declaration:\n#include <common>\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nuniform float time;\nuniform float amount;\n\nfloat maxspeed = 5.0;\nfloat maxforce = 0.5;\n\nfloat speed = 1.;\n\nfloat magSq(vec3 vec) {\n  return (vec.x*vec.x + vec.y*vec.y + vec.z*vec.z);\n}\n\nvec3 limit(vec3 vec, float max) {\n  if (magSq(vec) > max*max) {\n    vec = normalize(vec);\n    vec *= max;\n  }\n  return vec;\n}\n\nvoid main() {\n\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    float idParticle = uv.y * resolution.x + uv.x;\n\n    vec4 tmpVel = texture2D( textureVelocity, uv );\n    vec4 tmpPos = texture2D( texturePosition, uv );\n    vec4 tmpAcc = texture2D( textureAcceleration, uv );\n\n//    vec3 vel = vec3(tmpVel.xyz);\n    vec3 vel = vec3(tmpVel.xyz);\n\n    tmpPos.y<=0.0?(vel = vec3(vel.x*0.4,abs(vel.y)*0.4,vel.z*0.4)):vec3(0.0);\n    (tmpPos.y<=0.001)?tmpVel.w += 1.0:tmpVel.w = 0.;\n//    (amount==0.?tmpVel.w = 0.0:0.0);\n\n    vel += tmpAcc.xyz*(amount==0.?vec3(0.0,1.0,0.0):vec3(1.0,1.0,1.0));\n//    vel += vec3(0.0,0.0,0.0);\n\n    //vel.y *= (tmpPos.w>0.0?1.0:-1.0);\n    //abs(vel.y)<0.01?vel.y = 0.01*(vel.y>0.0?-1.0:1.0):0.;\n\n//    float theta = snoise( tmpPos.xyz * (0.7) )*6.28;\n    //vel -= vec3( cos(theta), sin(theta), 0.0 )*0.0001;\n\n//    float theta = snoise( tmpPos.xyz * (0.3 + idParticle*0.0005 + cos(time)*0.1)  )*6.28;\n//    vel += vec3( cos(theta), sin(theta), 0.0 ) * 0.01;\n\n//    vel.z *= -0.;\n//    vel.z -= 0.05;\n//    vel.y += 5.;\n\n    // vel.w is the life of the each particle\n    gl_FragColor = vec4( vel.xyz, tmpVel.w );\n}"]),L=h(["#define GLSLIFY 1\n// For PI declaration:\n#include <common>\n\nuniform float time;\n\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nconst float frag = 1.0 / 128.0;\nconst float texShift = 0.5 * frag;\n\nfloat rand1(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat magSq(vec3 vec) {\n  return (vec.x*vec.x + vec.y*vec.y + vec.z*vec.z);\n}\n\nvec3 limit(vec3 vec, float max) {\n  if (magSq(vec) > max*max) {\n    vec = normalize(vec);\n    vec *= max;\n  }\n  return vec;\n}\n\nvoid main() {\n\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    float idParticle = uv.y * resolution.x + uv.x;\n\n    vec4 tmpVel = texture2D( textureVelocity,     uv );\n    vec4 tmpPos = texture2D( texturePosition,     uv );\n    vec4 tmpAcc = texture2D( textureAcceleration, uv );\n\n    float index = tmpPos.w;\n    float pu = fract(index * frag + texShift);\n    float pv = floor(index * frag) * frag + texShift;\n    vec3 tmpDan = texture2D( texture1, vec2(pu, pv)).rgb * 2.0 - 1.0;\n    vec3 tmpDan2 = texture2D( texture2, vec2(pu, pv)).rgb * 2.0 - 1.0;\n\n//    vec3 acc = ((tmpPos.xyz - tmpVel.xyz) - tmpDan) * 0.001;\n//    vec3 acc = vec3(tmpAcc.xyz);\n//    vec3 acc = vec3( 0.0000, -0.001, -0.001);\n//    vec3 acc = vec3( 0.0, 0.0, 0.0);\n//    vec3 acc = (-tmpDan - (tmpPos.xyz + tmpVel.xyz)) * 0.01;\n\n//    vec3 acc = (tmpDan-tmpDan2 )*0.08 + vec3( 0.0000, -0.001, 0.000);\n\n    vec3 acc = tmpAcc.xyz;\n    vec3 dx = limit(tmpDan-tmpDan2,0.06);\n    (tmpVel.w>10.)?(acc = (dx )*0.015 + vec3( 0.0000, -0.001-rand1(tmpDan.xz)*0.0005, 0.000)):vec3(0.0);\n//    (tmpVel.w>10.)?(acc = (tmpDan-tmpDan2 )*0.001 + vec3( 0.0000, -0.0001-rand1(tmpDan.xz)*0.00005, -0.001)):vec3(0.0);\n\n    (tmpVel.w>10.)?tmpAcc.w = 0.0:tmpAcc.w += 1.0;\n\n    // acc.w is the time of after particle born\n    gl_FragColor = vec4( acc.xyz, tmpAcc.w );\n\n}"]);
window.scene=f,window.THREE=THREE;var R,A,S=!0,k=[],O=[];window.playList=k,window.stopList=O;var H,_,j,F,I,V,N,U,B,G,Y,q=new THREE.Clock,W=720,Z=W*W,X=new THREE.PolarGridHelper(1,1);f.add(X);var K,Q=new THREE.Scene,J=new THREE.WebGLRenderTarget(128,128,{minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter}),ee=new THREE.WebGLRenderTarget(128,128,{minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter}),ne=new THREE.Vector3(0,.3,0),te=new THREE.Vector3(0,.3,0),oe=0,ie=0;o(),window.playAnimation=s;var ae=function(e,n){for(var t,o,i=0;i<H.geometry.animations.length;++i)H.geometry.animations[i].name===e&&(t=H.geometry.animations[i],o=H.mixer.clipAction(t));n?o.repetitions="Infinity":o.repetitions=0,o.play()};window.changeAnimation=ae,window.animationState="dance1"},{"./lib/CreateThree":1,"./lib/SoundCloud.js":3,glslify:5}],5:[function(e,n,t){n.exports=function(e){"string"==typeof e&&(e=[e]);for(var n=[].slice.call(arguments,1),t=[],o=0;o<e.length-1;o++)t.push(e[o],n[o]||"");return t.push(e[o]),t.join("")}},{}],6:[function(e,n,t){n.exports=function(e){function n(n,t){function o(){return 2*Math.PI/60/60*O.autoRotateSpeed}function i(){return Math.pow(.95,O.zoomSpeed)}function a(e){U.theta-=e}function r(e){U.phi-=e}function c(n){O.object instanceof e.PerspectiveCamera?B/=n:O.object instanceof e.OrthographicCamera?(O.object.zoom=Math.max(O.minZoom,Math.min(O.maxZoom,O.object.zoom*n)),O.object.updateProjectionMatrix(),Y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),O.enableZoom=!1)}function s(n){O.object instanceof e.PerspectiveCamera?B*=n:O.object instanceof e.OrthographicCamera?(O.object.zoom=Math.max(O.minZoom,Math.min(O.maxZoom,O.object.zoom/n)),O.object.updateProjectionMatrix(),Y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),O.enableZoom=!1)}function l(e){q.set(e.clientX,e.clientY)}function v(e){$.set(e.clientX,e.clientY)}function u(e){X.set(e.clientX,e.clientY)}function m(e){W.set(e.clientX,e.clientY),Z.subVectors(W,q);var n=O.domElement===document?O.domElement.body:O.domElement;a(2*Math.PI*Z.x/n.clientWidth*O.rotateSpeed),r(2*Math.PI*Z.y/n.clientHeight*O.rotateSpeed),q.copy(W),O.update()}function d(e){J.set(e.clientX,e.clientY),ee.subVectors(J,$),ee.y>0?c(i()):ee.y<0&&s(i()),$.copy(J),O.update()}function p(e){K.set(e.clientX,e.clientY),Q.subVectors(K,X),oe(Q.x,Q.y),X.copy(K),O.update()}function x(e){}function f(e){e.deltaY<0?s(i()):e.deltaY>0&&c(i()),O.update()}function y(e){switch(e.keyCode){case O.keys.UP:oe(0,O.keyPanSpeed),O.update();break;case O.keys.BOTTOM:oe(0,-O.keyPanSpeed),O.update();break;case O.keys.LEFT:oe(O.keyPanSpeed,0),O.update();break;case O.keys.RIGHT:oe(-O.keyPanSpeed,0),O.update()}}function h(e){q.set(e.touches[0].pageX,e.touches[0].pageY)}function g(e){var n=e.touches[0].pageX-e.touches[1].pageX,t=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(n*n+t*t);$.set(0,o)}function w(e){X.set(e.touches[0].pageX,e.touches[0].pageY)}function b(e){W.set(e.touches[0].pageX,e.touches[0].pageY),Z.subVectors(W,q);var n=O.domElement===document?O.domElement.body:O.domElement;a(2*Math.PI*Z.x/n.clientWidth*O.rotateSpeed),r(2*Math.PI*Z.y/n.clientHeight*O.rotateSpeed),q.copy(W),O.update()}function z(e){var n=e.touches[0].pageX-e.touches[1].pageX,t=e.touches[0].pageY-e.touches[1].pageY,o=Math.sqrt(n*n+t*t);J.set(0,o),ee.subVectors(J,$),ee.y>0?s(i()):ee.y<0&&c(i()),$.copy(J),O.update()}function E(e){K.set(e.touches[0].pageX,e.touches[0].pageY),Q.subVectors(K,X),oe(Q.x,Q.y),X.copy(K),O.update()}function P(e){}function C(e){if(O.enabled!==!1){if(e.preventDefault(),e.button===O.mouseButtons.ORBIT){if(O.enableRotate===!1)return;l(e),I=F.ROTATE}else if(e.button===O.mouseButtons.ZOOM){if(O.enableZoom===!1)return;v(e),I=F.DOLLY}else if(e.button===O.mouseButtons.PAN){if(O.enablePan===!1)return;u(e),I=F.PAN}I!==F.NONE&&(document.addEventListener("mousemove",T,!1),document.addEventListener("mouseup",M,!1),O.dispatchEvent(_))}}function T(e){if(O.enabled!==!1)if(e.preventDefault(),I===F.ROTATE){if(O.enableRotate===!1)return;m(e)}else if(I===F.DOLLY){if(O.enableZoom===!1)return;d(e)}else if(I===F.PAN){if(O.enablePan===!1)return;p(e)}}function M(e){O.enabled!==!1&&(x(e),document.removeEventListener("mousemove",T,!1),document.removeEventListener("mouseup",M,!1),O.dispatchEvent(j),I=F.NONE)}function D(e){O.enabled===!1||O.enableZoom===!1||I!==F.NONE&&I!==F.ROTATE||(e.preventDefault(),e.stopPropagation(),f(e),O.dispatchEvent(_),O.dispatchEvent(j))}function L(e){O.enabled!==!1&&O.enableKeys!==!1&&O.enablePan!==!1&&y(e)}function R(e){if(O.enabled!==!1){switch(e.touches.length){case 1:if(O.enableRotate===!1)return;h(e),I=F.TOUCH_ROTATE;break;case 2:if(O.enableZoom===!1)return;g(e),I=F.TOUCH_DOLLY;break;case 3:if(O.enablePan===!1)return;w(e),I=F.TOUCH_PAN;break;default:I=F.NONE}I!==F.NONE&&O.dispatchEvent(_)}}function A(e){if(O.enabled!==!1)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:if(O.enableRotate===!1)return;if(I!==F.TOUCH_ROTATE)return;b(e);break;case 2:if(O.enableZoom===!1)return;if(I!==F.TOUCH_DOLLY)return;z(e);break;case 3:if(O.enablePan===!1)return;if(I!==F.TOUCH_PAN)return;E(e);break;default:I=F.NONE}}function S(e){O.enabled!==!1&&(P(e),O.dispatchEvent(j),I=F.NONE)}function k(e){e.preventDefault()}this.object=n,this.domElement=void 0!==t?t:document,this.enabled=!0,this.target=new e.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-(1/0),this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={ORBIT:e.MOUSE.LEFT,ZOOM:e.MOUSE.MIDDLE,PAN:e.MOUSE.RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return N.phi},this.getAzimuthalAngle=function(){return N.theta},this.reset=function(){O.target.copy(O.target0),O.object.position.copy(O.position0),O.object.zoom=O.zoom0,O.object.updateProjectionMatrix(),O.dispatchEvent(H),O.update(),I=F.NONE},this.update=function(){var t=new e.Vector3,i=(new e.Quaternion).setFromUnitVectors(n.up,new e.Vector3(0,1,0)),r=i.clone().inverse(),c=new e.Vector3,s=new e.Quaternion;return function(){var e=O.object.position;return t.copy(e).sub(O.target),t.applyQuaternion(i),N.setFromVector3(t),O.autoRotate&&I===F.NONE&&a(o()),N.theta+=U.theta,N.phi+=U.phi,N.theta=Math.max(O.minAzimuthAngle,Math.min(O.maxAzimuthAngle,N.theta)),N.phi=Math.max(O.minPolarAngle,Math.min(O.maxPolarAngle,N.phi)),N.makeSafe(),N.radius*=B,N.radius=Math.max(O.minDistance,Math.min(O.maxDistance,N.radius)),O.target.add(G),t.setFromSpherical(N),t.applyQuaternion(r),e.copy(O.target).add(t),O.object.lookAt(O.target),O.enableDamping===!0?(U.theta*=1-O.dampingFactor,U.phi*=1-O.dampingFactor):U.set(0,0,0),B=1,G.set(0,0,0),!!(Y||c.distanceToSquared(O.object.position)>V||8*(1-s.dot(O.object.quaternion))>V)&&(O.dispatchEvent(H),c.copy(O.object.position),s.copy(O.object.quaternion),Y=!1,!0)}}(),this.dispose=function(){O.domElement.removeEventListener("contextmenu",k,!1),O.domElement.removeEventListener("mousedown",C,!1),O.domElement.removeEventListener("wheel",D,!1),O.domElement.removeEventListener("touchstart",R,!1),O.domElement.removeEventListener("touchend",S,!1),O.domElement.removeEventListener("touchmove",A,!1),document.removeEventListener("mousemove",T,!1),document.removeEventListener("mouseup",M,!1),window.removeEventListener("keydown",L,!1)};var O=this,H={type:"change"},_={type:"start"},j={type:"end"},F={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5},I=F.NONE,V=1e-6,N=new e.Spherical,U=new e.Spherical,B=1,G=new e.Vector3,Y=!1,q=new e.Vector2,W=new e.Vector2,Z=new e.Vector2,X=new e.Vector2,K=new e.Vector2,Q=new e.Vector2,$=new e.Vector2,J=new e.Vector2,ee=new e.Vector2,ne=function(){var n=new e.Vector3;return function(e,t){n.setFromMatrixColumn(t,0),n.multiplyScalar(-e),G.add(n)}}(),te=function(){var n=new e.Vector3;return function(e,t){n.setFromMatrixColumn(t,1),n.multiplyScalar(e),G.add(n)}}(),oe=function(){var n=new e.Vector3;return function(t,o){var i=O.domElement===document?O.domElement.body:O.domElement;if(O.object instanceof e.PerspectiveCamera){var a=O.object.position;n.copy(a).sub(O.target);var r=n.length();r*=Math.tan(O.object.fov/2*Math.PI/180),ne(2*t*r/i.clientHeight,O.object.matrix),te(2*o*r/i.clientHeight,O.object.matrix)}else O.object instanceof e.OrthographicCamera?(ne(t*(O.object.right-O.object.left)/O.object.zoom/i.clientWidth,O.object.matrix),te(o*(O.object.top-O.object.bottom)/O.object.zoom/i.clientHeight,O.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),O.enablePan=!1)}}();O.domElement.addEventListener("contextmenu",k,!1),O.domElement.addEventListener("mousedown",C,!1),O.domElement.addEventListener("wheel",D,!1),O.domElement.addEventListener("touchstart",R,!1),O.domElement.addEventListener("touchend",S,!1),O.domElement.addEventListener("touchmove",A,!1),window.addEventListener("keydown",L,!1),this.update()}return n.prototype=Object.create(e.EventDispatcher.prototype),n.prototype.constructor=n,Object.defineProperties(n.prototype,{center:{get:function(){return console.warn("THREE.OrbitControls: .center has been renamed to .target"),this.target}},noZoom:{get:function(){return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),!this.enableZoom},set:function(e){console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),this.enableZoom=!e}},noRotate:{get:function(){return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),!this.enableRotate},set:function(e){console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),this.enableRotate=!e}},noPan:{get:function(){return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),!this.enablePan},set:function(e){console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),this.enablePan=!e}},noKeys:{get:function(){return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),!this.enableKeys},set:function(e){console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),this.enableKeys=!e}},staticMoving:{get:function(){return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),!this.enableDamping},set:function(e){console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),this.enableDamping=!e}},dynamicDampingFactor:{get:function(){return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor},set:function(e){console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor=e}}}),n}},{}]},{},[4]);
